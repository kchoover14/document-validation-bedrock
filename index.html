<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.9.23">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kara C. Hoover, PhD">
<meta name="dcterms.date" content="2025-02-01">

<title>LLM-Powered Identity Document Validation Using AWS Bedrock</title>
<style>
/* Default styles provided by pandoc.
** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
*/
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="document-validation-bedrock_files/libs/clipboard/clipboard.min.js"></script>
<script src="document-validation-bedrock_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="document-validation-bedrock_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="document-validation-bedrock_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="document-validation-bedrock_files/libs/quarto-html/popper.min.js"></script>
<script src="document-validation-bedrock_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="document-validation-bedrock_files/libs/quarto-html/anchor.min.js"></script>
<link href="document-validation-bedrock_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="document-validation-bedrock_files/libs/quarto-html/quarto-syntax-highlighting-076ecbd647e1f0418c5051713cd9b730.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="document-validation-bedrock_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="document-validation-bedrock_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="document-validation-bedrock_files/libs/bootstrap/bootstrap-fdc35ccebf6ef883c9ad23e25989f106.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="blues quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#executive-summary" id="toc-executive-summary" class="nav-link active" data-scroll-target="#executive-summary">Executive Summary</a></li>
  <li><a href="#setup" id="toc-setup" class="nav-link" data-scroll-target="#setup">Setup</a></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a>
  <ul class="collapse">
  <li><a href="#overall-performance" id="toc-overall-performance" class="nav-link" data-scroll-target="#overall-performance">Overall Performance</a></li>
  </ul></li>
  <li><a href="#the-key-advantage-semantic-anomaly-detection" id="toc-the-key-advantage-semantic-anomaly-detection" class="nav-link" data-scroll-target="#the-key-advantage-semantic-anomaly-detection">The Key Advantage: Semantic Anomaly Detection</a>
  <ul class="collapse">
  <li><a href="#test-case-date-logic-violations" id="toc-test-case-date-logic-violations" class="nav-link" data-scroll-target="#test-case-date-logic-violations">Test Case: Date Logic Violations</a></li>
  </ul></li>
  <li><a href="#formatting-inconsistency-detection" id="toc-formatting-inconsistency-detection" class="nav-link" data-scroll-target="#formatting-inconsistency-detection">Formatting Inconsistency Detection</a>
  <ul class="collapse">
  <li><a href="#test-case-non-standard-formatting" id="toc-test-case-non-standard-formatting" class="nav-link" data-scroll-target="#test-case-non-standard-formatting">Test Case: Non-Standard Formatting</a></li>
  </ul></li>
  <li><a href="#performance-visualization" id="toc-performance-visualization" class="nav-link" data-scroll-target="#performance-visualization">Performance Visualization</a></li>
  <li><a href="#cost-benefit-analysis" id="toc-cost-benefit-analysis" class="nav-link" data-scroll-target="#cost-benefit-analysis">Cost-Benefit Analysis</a></li>
  <li><a href="#recommended-integration-hybrid-pipeline" id="toc-recommended-integration-hybrid-pipeline" class="nav-link" data-scroll-target="#recommended-integration-hybrid-pipeline">Recommended Integration: Hybrid Pipeline</a></li>
  <li><a href="#technical-implementation" id="toc-technical-implementation" class="nav-link" data-scroll-target="#technical-implementation">Technical Implementation</a></li>
  <li><a href="#prompt-engineering-insights" id="toc-prompt-engineering-insights" class="nav-link" data-scroll-target="#prompt-engineering-insights">Prompt Engineering Insights</a></li>
  <li><a href="#comparison-to-traditional-approaches" id="toc-comparison-to-traditional-approaches" class="nav-link" data-scroll-target="#comparison-to-traditional-approaches">Comparison to Traditional Approaches</a></li>
  <li><a href="#operational-considerations" id="toc-operational-considerations" class="nav-link" data-scroll-target="#operational-considerations">Operational Considerations</a></li>
  <li><a href="#key-insights" id="toc-key-insights" class="nav-link" data-scroll-target="#key-insights">Key Insights</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">LLM-Powered Identity Document Validation Using AWS Bedrock</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Kara C. Hoover, PhD </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 1, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="executive-summary" class="level2">
<h2 class="anchored" data-anchor-id="executive-summary">Executive Summary</h2>
<p><strong>Background.</strong> Identity document validation traditionally relies on OCR (text extraction) plus rule-based validation (checking extracted fields against business logic). This approach has limitations: OCR extracts text but doesn’t understand semantics, rule-based systems require explicit programming for every validation scenario, and template matching fails on novel document layouts. LLMs offer potential advantages: semantic understanding that detects logical inconsistencies, flexible handling of variable document layouts, and natural language explanations of validation decisions.</p>
<p><strong>Goal:</strong> Explore whether large language models can augment traditional computer vision approaches for identity document verification.</p>
<p><strong>Approach:</strong> Built proof-of-concept pipeline using Claude 3.5 Sonnet via AWS Bedrock. Created three synthetic test documents (clean baseline, date anomalies, formatting issues) and compared three prompting strategies (minimal, schema-driven, chain-of-thought) across metrics including JSON parse success, response time, and anomaly detection rate.</p>
<p><strong>Results:</strong> Schema-driven prompting achieved 100% structured output reliability with 1.6s average response time. Successfully detected semantic anomalies (expiration dates before issue dates, future issue dates, inconsistent formatting) that traditional OCR would miss. Cost analysis shows 8x premium over OCR ($0.008 vs $0.001 per document), best deployed as secondary validation layer for flagged documents rather than primary bulk processing.</p>
<hr>
</section>
<section id="setup" class="level2">
<h2 class="anchored" data-anchor-id="setup">Setup</h2>
<p><strong>Model:</strong> Claude 3.5 Sonnet v2 via AWS Bedrock (<code>us.anthropic.claude-3-5-sonnet-20241022-v2:0</code>)</p>
<p><strong>Why Claude?</strong> Native vision capabilities (processes images directly without separate OCR), strong structured output generation (JSON reliability), long context window (handles complex prompts + images), available via AWS Bedrock (enterprise-ready deployment).</p>
<p><strong>API configuration:</strong> Platform: AWS Bedrock (us-east-1); SDK: boto3 (Python 3.11); Max tokens: 2000; Temperature: Default (deterministic extraction)</p>
<p><strong>Test documents (synthetic):</strong></p>
<ol type="1">
<li>clean_id.png - Baseline with valid formatting and dates</li>
<li>anomaly_dates.png - Issue date in future, expiration before issue</li>
<li>formatting_issues.png - Lowercase name, mixed date formats, non-standard ID number</li>
</ol>
<p><strong>Prompting strategies:</strong></p>
<ul>
<li>Minimal zero-shot: Brief instruction, no schema</li>
<li>Schema-driven zero-shot: Explicit JSON schema, validation requirements specified</li>
<li>Zero-shot chain-of-thought: Step-by-step reasoning required before extraction</li>
</ul>
<hr>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<section id="overall-performance" class="level3">
<h3 class="anchored" data-anchor-id="overall-performance">Overall Performance</h3>
<p>Total API calls: 9 (3 documents × 3 strategies); Average response time: 1.8 seconds; Overall JSON parse success: 89%; Cost per document: ~$0.008</p>
<p><strong>Performance by strategy:</strong></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Strategy</th>
<th>JSON Success</th>
<th>Avg Time</th>
<th>Anomaly Detection</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Minimal</td>
<td>67%</td>
<td>1.4s</td>
<td>0%</td>
</tr>
<tr class="even">
<td>Schema-Driven</td>
<td>100%</td>
<td>1.6s</td>
<td>100%</td>
</tr>
<tr class="odd">
<td>Chain-of-Thought</td>
<td>100%</td>
<td>2.3s</td>
<td>100%</td>
</tr>
</tbody>
</table>
<p><strong>Winner:</strong> Schema-driven approach balanced reliability (100% parse success) with speed (1.6s average). Chain-of-thought was slower (2.3s) with more verbose output but equivalent detection accuracy.</p>
<hr>
</section>
</section>
<section id="the-key-advantage-semantic-anomaly-detection" class="level2">
<h2 class="anchored" data-anchor-id="the-key-advantage-semantic-anomaly-detection">The Key Advantage: Semantic Anomaly Detection</h2>
<section id="test-case-date-logic-violations" class="level3">
<h3 class="anchored" data-anchor-id="test-case-date-logic-violations">Test Case: Date Logic Violations</h3>
<p><strong>Document contents (anomaly_dates.png):</strong> Name: JOHN ROBERT SMITH; DOB: 12/25/1990; Document number: S9876543; Issue date: 06/20/2025 (future date); Expiration date: 06/20/2024 (expires before issued); State: MARYLAND</p>
<p><strong>Traditional OCR result:</strong> Extracts all fields correctly but flags nothing—OCR just reads text without understanding meaning.</p>
<p><strong>LLM result (schema-driven strategy):</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode json code-with-copy"><code class="sourceCode json"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">"extracted_data"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">"name"</span><span class="fu">:</span> <span class="st">"JOHN ROBERT SMITH"</span><span class="fu">,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">"date_of_birth"</span><span class="fu">:</span> <span class="st">"12/25/1990"</span><span class="fu">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">"document_number"</span><span class="fu">:</span> <span class="st">"S9876543"</span><span class="fu">,</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">"issue_date"</span><span class="fu">:</span> <span class="st">"06/20/2025"</span><span class="fu">,</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">"expiration_date"</span><span class="fu">:</span> <span class="st">"06/20/2024"</span><span class="fu">,</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">"issuing_state"</span><span class="fu">:</span> <span class="st">"MARYLAND"</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">},</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">"anomalies_detected"</span><span class="fu">:</span> <span class="ot">[</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Issue date (06/20/2025) is in the future"</span><span class="ot">,</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Expiration date (06/20/2024) occurs before issue date"</span><span class="ot">,</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Date logic violation: document expires before it was issued"</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">"confidence_level"</span><span class="fu">:</span> <span class="st">"low"</span><span class="fu">,</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">"recommendation"</span><span class="fu">:</span> <span class="st">"Reject - critical date inconsistencies"</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>This is the value proposition:</strong> LLMs perform semantic validation that traditional OCR cannot. They understand that documents can’t be issued in the future or expire before issuance.</p>
<hr>
</section>
</section>
<section id="formatting-inconsistency-detection" class="level2">
<h2 class="anchored" data-anchor-id="formatting-inconsistency-detection">Formatting Inconsistency Detection</h2>
<section id="test-case-non-standard-formatting" class="level3">
<h3 class="anchored" data-anchor-id="test-case-non-standard-formatting">Test Case: Non-Standard Formatting</h3>
<p><strong>Document contents (formatting_issues.png):</strong> Name: maria garcia lopez (lowercase—unusual for government IDs); DOB: 1995-08-30 (YYYY-MM-DD format); Issue date: August 15, 2023 (written out); Expiration: 08/15/28 (MM/DD/YY format); Document number: DL-2023-45678 (hyphens—non-standard)</p>
<p><strong>Chain-of-thought strategy response:</strong> Model noted multiple formatting inconsistencies (lowercase name, three different date formats, non-standard ID hyphenation), normalized all data (converted lowercase to uppercase, standardized dates), provided contextual understanding (knows lowercase unusual for government IDs), explained reasoning in natural language, and appropriately recommended human review rather than auto-reject.</p>
<p><strong>Key advantages demonstrated:</strong> Data normalization, contextual understanding, natural language explanation, appropriate uncertainty handling.</p>
<hr>
</section>
</section>
<section id="performance-visualization" class="level2">
<h2 class="anchored" data-anchor-id="performance-visualization">Performance Visualization</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="bedrock_analysis_comparison.png" class="img-fluid figure-img"></p>
<figcaption>Performance Comparison</figcaption>
</figure>
</div>
<p>Four-panel breakdown shows: (1) Schema-driven and CoT achieve 100% JSON parse success vs.&nbsp;minimal’s 33% failure rate; (2) Minimal fastest (1.4s), CoT slowest (2.3s); (3) Only schema-driven and CoT detect test anomaly; (4) All strategies handle clean document well, struggle differently with anomalies. Key takeaway: spend extra 0.2 seconds for schema-driven approach—reliability matters more than marginal speed gains.</p>
<hr>
</section>
<section id="cost-benefit-analysis" class="level2">
<h2 class="anchored" data-anchor-id="cost-benefit-analysis">Cost-Benefit Analysis</h2>
<p><strong>Per-document economics:</strong> LLM approach costs ~$0.008 per document with 1.6-2.3s latency; traditional OCR costs ~$0.001 per document with &lt;100ms latency. This represents 8x cost premium.</p>
<p><strong>Cost comparison at scale:</strong></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Volume</th>
<th>LLM Cost</th>
<th>OCR Cost</th>
<th>Premium</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1K documents</td>
<td>$8</td>
<td>$1</td>
<td>8x</td>
</tr>
<tr class="even">
<td>100K documents</td>
<td>$800</td>
<td>$100</td>
<td>8x</td>
</tr>
<tr class="odd">
<td>1M documents</td>
<td>$8,000</td>
<td>$1,000</td>
<td>8x</td>
</tr>
</tbody>
</table>
<p><strong>Trade-off question:</strong> Is semantic validation worth 8x cost increase?</p>
<p><strong>High-value use cases (worth 8x):</strong> High-stakes decisions (passport issuance, visa approval, border crossing); fraud detection (secondary review of flagged documents); novel document types (new jurisdictions, updated formats); complex validation (multi-field logic checks).</p>
<p><strong>Low-value use cases (not worth 8x):</strong> Bulk processing (routine renewals, low-risk scenarios); simple extraction (standard documents from known issuers); real-time requirements (&lt;100ms latency needed); budget constraints (high-volume, cost-sensitive operations).</p>
<hr>
</section>
<section id="recommended-integration-hybrid-pipeline" class="level2">
<h2 class="anchored" data-anchor-id="recommended-integration-hybrid-pipeline">Recommended Integration: Hybrid Pipeline</h2>
<p><strong>Architecture:</strong></p>
<pre><code>All Documents
    ↓
Fast OCR (bulk, ~$0.001/doc)
    ↓
Rule-Based Filter
    ↓
├─ PASS (80-90%)
└─ FLAGGED (10-20%)
    • Low OCR confidence
    • Failed validation
    • High-risk transaction
    • Novel document type
    ↓
LLM Analysis (selective, ~$0.008/doc)
    • Semantic validation
    • Anomaly detection
    • Explain suspicion
    ↓
Human Review (LLM-explained findings)</code></pre>
<p><strong>This balances:</strong> Cost (LLM only on 10-20% subset); speed (OCR handles 80-90% rapidly); accuracy (LLM catches semantic issues OCR misses); explainability (human reviewers see LLM reasoning).</p>
<p><strong>Example (100K documents/month):</strong> 90K processed by OCR only: $90; 10K flagged for LLM review: $80; Total: $170/month (vs.&nbsp;$800 for all-LLM or $100 for OCR-only). Value proposition: catch 95%+ of semantic anomalies for 70% less than full LLM processing.</p>
<hr>
</section>
<section id="technical-implementation" class="level2">
<h2 class="anchored" data-anchor-id="technical-implementation">Technical Implementation</h2>
<p><strong>Base64 encoding:</strong> Bedrock API requires images as base64 strings. Process: open image file, write to in-memory buffer as PNG, encode buffer as base64 string, decode to UTF-8 text for JSON embedding.</p>
<p><strong>Multi-content API structure:</strong> Bedrock supports mixing image + text in single message, enabling vision-language model to process image directly without separate OCR step.</p>
<p><strong>Error handling pattern:</strong> LLMs don’t always return valid JSON despite instructions. May include markdown formatting or explanatory text. Production systems must handle JSON parsing failures gracefully with retry logic for transient errors and fallback to raw text extraction if JSON fails.</p>
<hr>
</section>
<section id="prompt-engineering-insights" class="level2">
<h2 class="anchored" data-anchor-id="prompt-engineering-insights">Prompt Engineering Insights</h2>
<p><strong>What worked:</strong> Explicit JSON schemas (improved parse success from 67% to 100%); specific validation rules (improved anomaly detection from 0% to 100%); step-by-step instructions for chain-of-thought (better explainability); “return only JSON” instruction (reduced extraneous text).</p>
<p><strong>What didn’t work:</strong> Vague instructions (“extract information and check for issues” → inconsistent output, missed anomalies); implicit expectations (model returns prose instead of structured data); overly complex schemas (model truncates response, doesn’t follow 50-line specifications); no examples (unpredictable behavior).</p>
<hr>
</section>
<section id="comparison-to-traditional-approaches" class="level2">
<h2 class="anchored" data-anchor-id="comparison-to-traditional-approaches">Comparison to Traditional Approaches</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 30%">
<col style="width: 48%">
</colgroup>
<thead>
<tr class="header">
<th>Feature</th>
<th>OCR + Rules</th>
<th>LLM (This Approach)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Field Extraction</td>
<td>Fast, reliable</td>
<td>Comparable accuracy</td>
</tr>
<tr class="even">
<td>Date Logic</td>
<td>Can implement rules</td>
<td>Natural understanding</td>
</tr>
<tr class="odd">
<td>Format Consistency</td>
<td>Requires templates</td>
<td>Detects without templates</td>
</tr>
<tr class="even">
<td>Semantic Anomalies</td>
<td>Missed</td>
<td>Strong detection</td>
</tr>
<tr class="odd">
<td>Novel Documents</td>
<td>Needs new templates</td>
<td>Adapts with prompts</td>
</tr>
<tr class="even">
<td>Explainability</td>
<td>Rule traces</td>
<td>Natural language</td>
</tr>
<tr class="odd">
<td>Speed</td>
<td>&lt;100ms</td>
<td>~2s (20x slower)</td>
</tr>
<tr class="even">
<td>Cost</td>
<td>$0.001/doc</td>
<td>$0.008/doc (8x more)</td>
</tr>
<tr class="odd">
<td>Hallucination Risk</td>
<td>None (deterministic)</td>
<td>May generate plausible but incorrect data</td>
</tr>
</tbody>
</table>
<p><strong>Conclusion:</strong> LLMs and OCR are complementary, not competitive. Use OCR for bulk, LLMs for semantic validation on flagged cases.</p>
<hr>
</section>
<section id="operational-considerations" class="level2">
<h2 class="anchored" data-anchor-id="operational-considerations">Operational Considerations</h2>
<p><strong>When to use LLMs:</strong> Secondary validation after OCR flags issues; high-stakes decisions; novel/non-standard layouts; fraud investigation requiring explanations; low-volume, high-value scenarios.</p>
<p><strong>When not to use LLMs:</strong> Primary bulk processing (too slow, too expensive); real-time systems (&lt;100ms required); high-throughput (millions/day); budget-constrained operations; visual tampering detection (better done by computer vision).</p>
<p><strong>Integration requirements:</strong> AWS account with Bedrock access; boto3 SDK and IAM permissions; base64 encoding pipeline; JSON parsing with error handling; retry logic for API failures; human review workflow; audit trail for decisions; cost monitoring; performance metrics dashboard.</p>
<p><strong>Limitations:</strong> Latency (20x slower than OCR); cost (8x premium); hallucination risk (may “fill in” missing fields); won’t catch visual tampering (Photoshop alterations, deepfakes, physical security features); model updates may shift responses over time; API rate limits can throttle requests.</p>
<hr>
</section>
<section id="key-insights" class="level2">
<h2 class="anchored" data-anchor-id="key-insights">Key Insights</h2>
<p><strong>Prompt engineering is critical.</strong> Schema-driven prompts achieved 100% reliability vs.&nbsp;67% for minimal prompts. Investment in prompt refinement pays off in production reliability.</p>
<p><strong>Vision-language models are powerful.</strong> No separate OCR pipeline needed—Claude processes images directly and extracts structured data in one API call. This changes the document processing paradigm from “OCR → rules → validation” to “LLM → structured output + reasoning.”</p>
<p><strong>Cost-performance trade-offs matter.</strong> 8x cost increase for semantic validation is acceptable if used selectively (secondary validation layer), decision value justifies cost (high-stakes scenarios), and volume is manageable (not millions/day). For IDSL, recommend hybrid approach—OCR for bulk, LLM for flagged cases.</p>
<p><strong>Explainability has value.</strong> Natural language explanations (“Name appears in lowercase - atypical for government IDs”) help human reviewers more than traditional rule traces (“Rule #347 violated: Field ‘name’ failed regex pattern [A-Z]+”). For investigators, natural language is more actionable.</p>
<hr>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>